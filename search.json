[{"path":"https://computationalproteomics.github.io/proteoDeconv/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 proteoDeconv authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/articles/proteoDeconv.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to proteoDeconv","text":"vignette describes basic workflow can used run proteoDeconv package.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/articles/proteoDeconv.html","id":"loading-required-packages","dir":"Articles","previous_headings":"","what":"Loading required packages","title":"Introduction to proteoDeconv","text":"First, let’s load necessary packages:","code":"library(proteoDeconv) library(readr) library(dplyr) library(tidyr) library(ggplot2)"},{"path":"https://computationalproteomics.github.io/proteoDeconv/articles/proteoDeconv.html","id":"example-data-overview","dir":"Articles","previous_headings":"","what":"Example data overview","title":"Introduction to proteoDeconv","text":"proteoDeconv includes two example datasets, subsets dataset PXD056050: Pure cell type samples: Proteomic measurements isolated CD8+ T cells monocytes. Mixed samples: Proteomic data experimental mixtures containing 50% CD8+ T cells 50% monocytes. Let’s load datasets: Let’s examine structure pure samples data: data matrix contains protein measurements (rows) across different samples (columns). sample names indicate cell type (CD8 CD8+ T cells Mono monocytes).","code":"pure_data_file <- system.file(\"extdata\", \"pure_samples_matrix.rds\", package = \"proteoDeconv\") pure_samples <- readRDS(pure_data_file)  mix_data_file <- system.file(\"extdata\", \"mixed_samples_matrix.rds\", package = \"proteoDeconv\") mixed_samples <- readRDS(mix_data_file) dim(pure_samples) #> [1] 3317    8  head(pure_samples) #>                            CD8+ T cells_1 CD8+ T cells_2 CD8+ T cells_3 #> IGKV3-15;IGKV3-7;IGKV3D-7              NA         799607       158030.0 #> IGLV3-16;IGLV3-25;IGLV3-27             NA             NA             NA #> IGKV3-11;IGKV3D-11                     NA         230449        41679.4 #> IGHV3OR16-9                            NA         151730        41122.8 #> GATD3;GATD3B                      2297760        2768020      3160440.0 #> IGKV1-13;IGKV1D-13                     NA             NA             NA #>                            CD8+ T cells_5 Monocytes_1 Monocytes_2 Monocytes_3 #> IGKV3-15;IGKV3-7;IGKV3D-7          477644      213180          NA      149232 #> IGLV3-16;IGLV3-25;IGLV3-27             NA          NA          NA          NA #> IGKV3-11;IGKV3D-11                 150046          NA          NA          NA #> IGHV3OR16-9                            NA          NA          NA          NA #> GATD3;GATD3B                      2765990     1864430     1859990     1653820 #> IGKV1-13;IGKV1D-13                     NA          NA          NA          NA #>                            Monocytes_4 #> IGKV3-15;IGKV3-7;IGKV3D-7           NA #> IGLV3-16;IGLV3-25;IGLV3-27          NA #> IGKV3-11;IGKV3D-11                  NA #> IGHV3OR16-9                         NA #> GATD3;GATD3B                   1906570 #> IGKV1-13;IGKV1D-13                  NA"},{"path":"https://computationalproteomics.github.io/proteoDeconv/articles/proteoDeconv.html","id":"data-preprocessing","dir":"Articles","previous_headings":"","what":"Data preprocessing","title":"Introduction to proteoDeconv","text":"Proper preprocessing important accurate deconvolution. preprocessing pipeline proteoDeconv includes several important steps: Let’s examine preprocessed data:","code":"pure_samples_preprocessed <- pure_samples |>   # Extract first gene group when multiple gene groups are present   extract_identifiers() |>   # Update gene symbols to current HGNC nomenclature   update_gene_symbols() |>   # Handle missing values by imputing with the lowest observed value   handle_missing_values() |>   # Resolve duplicate genes by keeping the row with highest median value   handle_duplicates() |>   # Scale the data (TPM-like normalization)   convert_to_tpm()  # Apply the same preprocessing to mixed samples mixed_samples_preprocessed <- mixed_samples |>   extract_identifiers() |>   update_gene_symbols() |>   handle_missing_values() |>   handle_duplicates() |>   convert_to_tpm() head(pure_samples_preprocessed) #>             CD8+ T cells_1 CD8+ T cells_2 CD8+ T cells_3 CD8+ T cells_5 #> IGKV3-15        0.08027906    19.66485501      8.2758047     22.9537904 #> IGLV3-16        0.08027906     0.06133261      0.1306014      0.1198471 #> IGKV3-11        0.08027906     5.66746686      2.1826905      7.2106515 #> IGHV3OR16-9     0.08027906     3.73151867      2.1535421      0.1198471 #> GATD3          73.96557868    68.07433147    165.5077151    132.9231702 #> IGKV1-13        0.08027906     0.06133261      0.1306014      0.1198471 #>             Monocytes_1 Monocytes_2 Monocytes_3 Monocytes_4 #> IGKV3-15      13.462733   0.1468999   9.8914941   0.1450565 #> IGLV3-16       0.157494   0.1468999   0.1653017   0.1450565 #> IGKV3-11       0.157494   0.1468999   0.1653017   0.1450565 #> IGHV3OR16-9    0.157494   0.1468999   0.1653017   0.1450565 #> GATD3        117.742395 109.5607297 109.6195913 110.8951904 #> IGKV1-13       0.157494   0.1468999   0.1653017   0.1450565"},{"path":"https://computationalproteomics.github.io/proteoDeconv/articles/proteoDeconv.html","id":"preprocessing-options","dir":"Articles","previous_headings":"Data preprocessing","what":"Preprocessing options","title":"Introduction to proteoDeconv","text":"proteoDeconv offers several options preprocessing step, evaluated impact deconvolution performance. information options, please refer function reference.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/articles/proteoDeconv.html","id":"creating-a-signature-matrix","dir":"Articles","previous_headings":"","what":"Creating a signature matrix","title":"Introduction to proteoDeconv","text":"signature matrix contains cell type-specific marker proteins used deconvolution. Signature matrices represent reference profiles pure cell populations. create one, first need establish samples correspond cell types: phenoclasses matrix shows cell type sample represents, required signature matrix generation. Now, can create signature matrix using CIBERSORTx: Let’s examine signature matrix: signature matrix contains proteins (rows) expression values cell type (columns). proteins selected based ability differentiate CD8+ T cells monocytes.","code":"mapping_rules <- list(   \"CD8+ T cells\" = \"CD8\", # Samples containing \"CD8\" will be classified as CD8+ T cells   \"Monocytes\" = \"Mono\" # Samples containing \"Mono\" will be classified as Monocytes )  phenoclasses <- create_phenoclasses(   pure_samples_preprocessed,   mapping_rules,   verbose = TRUE ) #> Using regex-based mapping rules #> Mapping to 'CD8+ T cells': CD8+ T cells_1, CD8+ T cells_2, CD8+ T cells_3, CD8+ T cells_5 #> Mapping to 'Monocytes': Monocytes_1, Monocytes_2, Monocytes_3, Monocytes_4  head(phenoclasses) #> # A tibble: 2 × 9 #>   cell_type  `CD8+ T cells_1` `CD8+ T cells_2` `CD8+ T cells_3` `CD8+ T cells_5` #>   <chr>                 <dbl>            <dbl>            <dbl>            <dbl> #> 1 CD8+ T ce…                1                1                1                1 #> 2 Monocytes                 2                2                2                2 #> # ℹ 4 more variables: Monocytes_1 <dbl>, Monocytes_2 <dbl>, Monocytes_3 <dbl>, #> #   Monocytes_4 <dbl> # Note: This requires a CIBERSORTx token to be set in .Renviron signature_matrix <- create_signature_matrix(   refsample = pure_samples_preprocessed,   phenoclasses = phenoclasses,   g_min = 200,   g_max = 400,   q_value = 0.01 ) dim(signature_matrix) #> [1] 426   2  # Look at the first rows head(signature_matrix) #>        CD8+ T cells  Monocytes #> ABCB6    77.6657360 353.951727 #> ABI3     34.3210650   0.152197 #> ABLIM1   12.5659965   0.152197 #> ACAA1     0.1000631   3.507357 #> ACADVL   55.3678625 222.706106 #> ACSL3     2.3622472  14.178111"},{"path":"https://computationalproteomics.github.io/proteoDeconv/articles/proteoDeconv.html","id":"performing-deconvolution","dir":"Articles","previous_headings":"","what":"Performing deconvolution","title":"Introduction to proteoDeconv","text":"Now can deconvolute mixed samples estimate cell type composition. proteoDeconv package supports multiple algorithms evaluated performance proteomics data. ’ll use EPIC algorithm (Racle et al. 2017): results show estimated proportion cell type mixed sample.","code":"results <- deconvolute(   algorithm = \"epic\",   data = mixed_samples_preprocessed,   signature = signature_matrix,   with_other_cells = FALSE # No need to calculate other cells in this case )  print(results) #>       CD8+ T cells Monocytes #> Mix_1    0.2691316 0.7308684 #> Mix_2    0.3341222 0.6658778 #> Mix_3    0.2074690 0.7925310 #> Mix_4    0.4650601 0.5349399"},{"path":"https://computationalproteomics.github.io/proteoDeconv/articles/proteoDeconv.html","id":"available-deconvolution-algorithms","dir":"Articles","previous_headings":"Performing deconvolution","what":"Available deconvolution algorithms","title":"Introduction to proteoDeconv","text":"proteoDeconv supports multiple deconvolution algorithms: EPIC (Racle et al. 2017): reference-based method uses constrained least-squares regression CIBERSORT (Newman et al. 2015): One first widely-used deconvolution tools, uses support vector regression (requires downloading CIBERSORT.R script CIBERSORT website) CIBERSORTx (Newman et al. 2019): enhanced version CIBERSORT includes batch correction features (requires token Docker) BayesDeBulk (Petralia et al. 2023): Bayesian approach specifically designed proteomics deconvolution use different algorithm, simply change algorithm parameter:","code":"# Example using a different algorithm results_cibersort <- deconvolute(   algorithm = \"cibersort\",   data = mixed_samples_preprocessed,   signature = signature_matrix )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/articles/proteoDeconv.html","id":"formatting-and-visualizing-results","dir":"Articles","previous_headings":"","what":"Formatting and visualizing results","title":"Introduction to proteoDeconv","text":"easier visualization, let’s convert results tidy format: Now, let’s create bar chart visualize cell type proportions:","code":"results_tidy <- as_tibble(results, rownames = \"sample\") |>   pivot_longer(     cols = -sample,     names_to = \"cell_type\",     values_to = \"cell_fraction\"   )  head(results_tidy) #> # A tibble: 6 × 3 #>   sample cell_type    cell_fraction #>   <chr>  <chr>                <dbl> #> 1 Mix_1  CD8+ T cells         0.269 #> 2 Mix_1  Monocytes            0.731 #> 3 Mix_2  CD8+ T cells         0.334 #> 4 Mix_2  Monocytes            0.666 #> 5 Mix_3  CD8+ T cells         0.207 #> 6 Mix_3  Monocytes            0.793 ggplot(results_tidy, aes(x = sample, y = cell_fraction, fill = cell_type)) +   geom_bar(stat = \"identity\", position = \"stack\") +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +   labs(     x = \"Sample\",     y = \"Estimated Proportion\",     fill = \"Cell Type\"   )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/articles/proteoDeconv.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Introduction to proteoDeconv","text":"vignette demonstrated basic workflow proteomics deconvolution using proteoDeconv package: Load preprocess data Create cell type signature matrix Perform deconvolution mixed samples Visualize interpret results advanced usage, refer package documentation function reference.","code":""},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Måns Zamore. Author, maintainer.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Zamore M (2025). proteoDeconv: Enabling Cell-Type Deconvolution Proteomics Data. R package version 0.1.0.9000, https://computationalproteomics.github.io/proteoDeconv/, https://github.com/ComputationalProteomics/proteoDeconv.","code":"@Manual{,   title = {proteoDeconv: Enabling Cell-Type Deconvolution of Proteomics Data},   author = {Måns Zamore},   year = {2025},   note = {R package version 0.1.0.9000, https://computationalproteomics.github.io/proteoDeconv/},   url = {https://github.com/ComputationalProteomics/proteoDeconv}, }"},{"path":"https://computationalproteomics.github.io/proteoDeconv/index.html","id":"proteodeconv","dir":"","previous_headings":"","what":"Enabling Cell-Type Deconvolution of Proteomics Data","title":"Enabling Cell-Type Deconvolution of Proteomics Data","text":"proteoDeconv R package facilitates deconvolution bulk proteomic data estimate cell type proportions. proteoDeconv, can preprocess data prepare deconvolution, create cell type signature matrices, perform deconvolution using multiple algorithms.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Enabling Cell-Type Deconvolution of Proteomics Data","text":"can install development version proteoDeconv GitHub:","code":"# install.packages(\"pak\") pak::pak(\"ComputationalProteomics/proteoDeconv\")"},{"path":"https://computationalproteomics.github.io/proteoDeconv/index.html","id":"usage-example","dir":"","previous_headings":"","what":"Usage example","title":"Enabling Cell-Type Deconvolution of Proteomics Data","text":"brief example demonstrates loading provided example data signature matrix package performing deconvolution. can learn vignette(\"proteoDeconv\").","code":"library(proteoDeconv)  # Load example data mix_data <- readRDS(system.file(\"extdata\", \"mixed_samples_matrix.rds\", package = \"proteoDeconv\")) signature <- readRDS(system.file(\"extdata\", \"cd8t_mono_signature_matrix.rds\", package = \"proteoDeconv\"))  # Preprocess data mix_processed <- mix_data |>   extract_identifiers() |>      # Extract IDs   update_gene_symbols() |>      # Update to current gene symbols   handle_missing_values() |>    # Handle NAs   handle_duplicates() |>        # Handle duplicates   convert_to_tpm()              # Scale to TPM-like scale  # Run deconvolution results <- deconvolute(   algorithm = \"epic\",   data = mix_processed,   signature = signature )  # View the deconvolution results print(results)"},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/index.html","id":"cibersortx","dir":"","previous_headings":"Prerequisites","what":"CIBERSORTx","title":"Enabling Cell-Type Deconvolution of Proteomics Data","text":"use proteoDeconv CIBERSORTx: Ensure Docker installed system. Register obtain token CIBERSORTx website. Set token email environment variables .Renviron file (file can home directory project folder):","code":"CIBERSORTX_TOKEN=your_token_here CIBERSORTX_EMAIL=your_email_here"},{"path":"https://computationalproteomics.github.io/proteoDeconv/index.html","id":"cibersort","dir":"","previous_headings":"Prerequisites","what":"CIBERSORT","title":"Enabling Cell-Type Deconvolution of Proteomics Data","text":"running proteoDeconv original CIBERSORT method, download CIBERSORT source code CIBERSORT website source executing deconvolutions:","code":"source(\"/path/to/CIBERSORT.R\")"},{"path":"https://computationalproteomics.github.io/proteoDeconv/index.html","id":"further-reference","dir":"","previous_headings":"","what":"Further reference","title":"Enabling Cell-Type Deconvolution of Proteomics Data","text":"detailed walkthrough complete workflow, see introduction proteoDeconv function reference.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/index.html","id":"support","dir":"","previous_headings":"","what":"Support","title":"Enabling Cell-Type Deconvolution of Proteomics Data","text":"bug reports inquiries, please open issue GitHub repository.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/convert_to_tpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert protein abundance data to TPM-like normalization — convert_to_tpm","title":"Convert protein abundance data to TPM-like normalization — convert_to_tpm","text":"Normalizes protein abundance data using TPM-like approach (Transcripts Per Million), adapting RNA-seq normalization method use proteomics data.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/convert_to_tpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert protein abundance data to TPM-like normalization — convert_to_tpm","text":"","code":"convert_to_tpm(data)"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/convert_to_tpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert protein abundance data to TPM-like normalization — convert_to_tpm","text":"data numeric matrix containing protein abundance data identifiers row names samples columns. Values linear scale, log-transformed.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/convert_to_tpm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert protein abundance data to TPM-like normalization — convert_to_tpm","text":"numeric matrix dimensions input, values normalized TPM-like scale (sum column equals 1 million).","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/convert_to_tpm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert protein abundance data to TPM-like normalization — convert_to_tpm","text":"function applies TPM-like normalization proteomics data, protein abundance value scaled total abundance sample multiplied 1 million. input data log-transformed, use unlog2_data first convert linear scale applying normalization.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/convert_to_tpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert protein abundance data to TPM-like normalization — convert_to_tpm","text":"","code":"# Create example protein abundance data matrix prot_mat <- matrix(abs(rnorm(12, mean = 500, sd = 200)), nrow = 4, ncol = 3) rownames(prot_mat) <- paste0(\"Protein\", 1:4) colnames(prot_mat) <- paste0(\"Sample\", 1:3)  # View original values and column sums print(prot_mat) #>            Sample1  Sample2  Sample3 #> Protein1 219.99130 624.3105 451.1601 #> Protein2 551.06341 729.6823 443.4589 #> Protein3  12.54728 135.6365 389.2601 #> Protein4 498.88574 450.5349 625.7964 print(colSums(prot_mat)) #>  Sample1  Sample2  Sample3  #> 1282.488 1940.164 1909.676   # Convert to TPM-like normalization tpm_mat <- convert_to_tpm(prot_mat)  # Verify that column sums equal 1 million print(tpm_mat) #>             Sample1   Sample2  Sample3 #> Protein1 171534.816 321782.31 236249.6 #> Protein2 429683.184 376093.06 232216.9 #> Protein3   9783.546  69909.79 203835.7 #> Protein4 388998.453 232214.84 327697.8 print(colSums(tpm_mat)) #> Sample1 Sample2 Sample3  #>   1e+06   1e+06   1e+06"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_phenoclasses.html","id":null,"dir":"Reference","previous_headings":"","what":"Create phenoclasses matrix for cell type deconvolution — create_phenoclasses","title":"Create phenoclasses matrix for cell type deconvolution — create_phenoclasses","text":"Generates phenotype classification matrix sample data use cell type deconvolution workflows. matrix maps samples respective cell types.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_phenoclasses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create phenoclasses matrix for cell type deconvolution — create_phenoclasses","text":"","code":"create_phenoclasses(   data,   mapping_rules,   verbose = FALSE,   return_format = c(\"tibble\", \"matrix\") )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_phenoclasses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create phenoclasses matrix for cell type deconvolution — create_phenoclasses","text":"data numeric matrix pure cell type profiles genes row names samples columns. Column names contain identifiers can mapped cell types. mapping_rules Either: 1. named list names cell type labels values regular expression patterns used match sample column names (e.g., list(\"CD8+ T cells\" = \"CD8\", \"Monocytes\" = \"Mono\")), 2. character vector length order colnames(data), directly specifying cell type sample. verbose Logical. TRUE, displays additional messages processing. return_format string specifying return format: \"matrix\" \"tibble\" (default).","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_phenoclasses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create phenoclasses matrix for cell type deconvolution — create_phenoclasses","text":"return_format \"matrix\", numeric matrix cell type groups rows samples columns. return_format \"tibble\", tibble \"cell_type\" column columns sample.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_phenoclasses.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create phenoclasses matrix for cell type deconvolution — create_phenoclasses","text":"function particularly useful preparing reference data signature matrix generation using CIBERSORTx. cell output encoded : 0 'Unknown' mappings 1 sample belongs cell type row 2 sample belongs different cell type","code":""},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_phenoclasses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create phenoclasses matrix for cell type deconvolution — create_phenoclasses","text":"","code":"if (FALSE) { # \\dontrun{ # Example using a named list of regex patterns pure_samples <- readRDS(system.file(\"extdata\", \"pure_samples_matrix.rds\",                                      package = \"proteoDeconv\"))  mapping_rules <- list(   \"CD8+ T cells\" = \"CD8\",   \"Monocytes\" = \"Mono\" )  phenoclasses1 <- create_phenoclasses(   data = pure_samples,   mapping_rules = mapping_rules,   verbose = TRUE )  # Example using a character vector of direct cell type assignments cell_types <- c(\"CD8+ T cells\", \"CD8+ T cells\", \"Monocytes\", \"Monocytes\", \"Unknown\") phenoclasses2 <- create_phenoclasses(   data = pure_samples,   mapping_rules = cell_types,   verbose = TRUE ) } # }"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_signature_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create signature matrix using CIBERSORTx — create_signature_matrix","title":"Create signature matrix using CIBERSORTx — create_signature_matrix","text":"Generates signature matrix reference profiles cell type classes using CIBERSORTx Docker image. signature matrix contains cell type-specific marker proteins used deconvolution.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_signature_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create signature matrix using CIBERSORTx — create_signature_matrix","text":"","code":"create_signature_matrix(   refsample = NULL,   phenoclasses = NULL,   g_min = 200,   g_max = 400,   q_value = 0.01,   replicates = 5,   sampling = 0.5,   fraction = 0.75,   filter = FALSE,   verbose = FALSE,   QN = FALSE,   single_cell = FALSE,   use_sudo = FALSE,   ... )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_signature_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create signature matrix using CIBERSORTx — create_signature_matrix","text":"refsample numeric matrix containing reference profiles genes row names samples columns. preprocessed data pure cell populations. phenoclasses numeric matrix, data frame, tibble containing cell type classification (0/1/2). provided matrix base data frame, cell types assumed row names. provided tibble, cell type identifiers included column. typically created using create_phenoclasses() function. g_min Minimum number genes per cell type signature matrix. Default 200. g_max Maximum number genes per cell type signature matrix. Default 400. q_value Q-value threshold differential expression. Default 0.01. replicates Number replicates use building reference file (relevant single_cell=TRUE). Default 5. sampling Fraction available gene expression profiles selected random sampling (relevant single_cell=TRUE). Default 0.5. fraction Fraction cells identity showing evidence expression (relevant single_cell=TRUE). Default 0.75. filter Logical indicating whether remove non-hematopoietic genes. Default FALSE. verbose Logical indicating whether print detailed output. Default FALSE. QN Logical indicating whether run quantile normalization. Default FALSE. single_cell Logical indicating whether create signature scRNA-Seq data. Default FALSE. use_sudo Logical indicating whether use sudo Docker commands. Default FALSE. ... Additional arguments passed function.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_signature_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create signature matrix using CIBERSORTx — create_signature_matrix","text":"numeric matrix genes rows cell types columns, representing expression profile cell type. signature matrix can used input deconvolution algorithms estimate cell type proportions mixed samples.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_signature_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create signature matrix using CIBERSORTx — create_signature_matrix","text":"function uses CIBERSORTx Docker image construct signature matrix based input reference profiles cell type classifications. CIBERSORTx token email must set environment variables either project directory's .Renviron file user's home directory .Renviron file.","code":""},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/create_signature_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create signature matrix using CIBERSORTx — create_signature_matrix","text":"","code":"if (FALSE) { # \\dontrun{ # Load preprocessed pure samples data pure_samples <- readRDS(system.file(\"extdata\", \"pure_samples_matrix.rds\",                                     package = \"proteoDeconv\"))  # Create phenoclasses for the samples mapping_rules <- list(   \"CD8+ T cells\" = \"CD8\",   \"Monocytes\" = \"Mono\" ) phenoclasses <- create_phenoclasses(   data = pure_samples,   mapping_rules = mapping_rules )  # Create signature matrix signature_matrix <- create_signature_matrix(   refsample = pure_samples,   phenoclasses = phenoclasses,   g_min = 200,   g_max = 400,   q_value = 0.01 ) } # }"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute.html","id":null,"dir":"Reference","previous_headings":"","what":"Deconvolute protein data using multiple algorithms — deconvolute","title":"Deconvolute protein data using multiple algorithms — deconvolute","text":"function provides unified interface deconvoluting protein gene expression data using various algorithms, making easy switch different deconvolution methods.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deconvolute protein data using multiple algorithms — deconvolute","text":"","code":"deconvolute(algorithm, data, signature = NULL, ...)"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deconvolute protein data using multiple algorithms — deconvolute","text":"algorithm string specifying deconvolution algorithm use. Options \"cibersortx\", \"cibersort\", \"epic\", \"bayesdebulk\". data numeric matrix containing protein gene expression data genes/proteins row names samples columns. signature numeric matrix containing reference signature genes/proteins row names cell types columns. Required supported algorithms. ... Additional arguments passed specific deconvolution functions.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deconvolute protein data using multiple algorithms — deconvolute","text":"numeric matrix samples rows cell types columns, representing estimated proportion cell type sample.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deconvolute protein data using multiple algorithms — deconvolute","text":"function supports multiple deconvolution algorithms: cibersortx: Uses Docker-based CIBERSORTx, requires Docker installation credentials (see deconvolute_cibersortx). cibersort: Uses R implementation CIBERSORT, requires sourcing original CIBERSORT.R script (see deconvolute_cibersort). epic: Uses EPIC algorithm performs constrained least squares regression (see deconvolute_epic). bayesdebulk: Uses BayesDeBulk Bayesian deconvolution algorithm (see deconvolute_bayesdebulk).","code":""},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deconvolute protein data using multiple algorithms — deconvolute","text":"","code":"if (FALSE) { # \\dontrun{ # Load example data data_file <- system.file(\"extdata\", \"mixed_samples_matrix.rds\", package = \"proteoDeconv\") mixed_samples <- readRDS(data_file)  signature_file <- system.file(\"extdata\", \"cd8t_mono_signature_matrix.rds\", package = \"proteoDeconv\") signature_matrix <- readRDS(signature_file)  # Using EPIC algorithm epic_results <- deconvolute(   algorithm = \"epic\",   data = mixed_samples,   signature = signature_matrix,   with_other_cells = TRUE )  # Using BayesDeBulk algorithm bayes_results <- deconvolute(   algorithm = \"bayesdebulk\",   data = mixed_samples,   signature = signature_matrix,   n_iter = 1000,   burn_in = 100 ) } # }"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_bayesdebulk.html","id":null,"dir":"Reference","previous_headings":"","what":"Deconvolute bulk proteome data using BayesDeBulk — deconvolute_bayesdebulk","title":"Deconvolute bulk proteome data using BayesDeBulk — deconvolute_bayesdebulk","text":"Deconvolutes bulk proteome data using BayesDeBulk algorithm estimate cell type proportions mixed samples based signature matrix.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_bayesdebulk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deconvolute bulk proteome data using BayesDeBulk — deconvolute_bayesdebulk","text":"","code":"deconvolute_bayesdebulk(   data,   signature,   n_iter = 1000,   burn_in = 100,   marker_selection = \"limma\",   ... )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_bayesdebulk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deconvolute bulk proteome data using BayesDeBulk — deconvolute_bayesdebulk","text":"data numeric matrix bulk proteome data gene identifiers row names samples columns. signature numeric matrix containing signature marker values gene identifiers row names cell types columns. n_iter Number iterations MCMC sampling; default 1000. burn_in Number burn-iterations discard; default 100. marker_selection method use marker selection: \"limma\" (default), \"simple\", pre-computed marker matrix. ... Additional arguments passed marker selection functions.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_bayesdebulk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deconvolute bulk proteome data using BayesDeBulk — deconvolute_bayesdebulk","text":"matrix containing cell type proportions samples rows cell types columns.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_bayesdebulk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deconvolute bulk proteome data using BayesDeBulk — deconvolute_bayesdebulk","text":"function calculates signature markers using specified marker selection method runs BayesDeBulk deconvolution algorithm. marker selection process identifies genes uniquely expressed specific cell types, used deconvolution.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_bayesdebulk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deconvolute bulk proteome data using BayesDeBulk — deconvolute_bayesdebulk","text":"","code":"if (FALSE) { # \\dontrun{ # Load example data and signature matrix data_file <- system.file(\"extdata\", \"mixed_samples_matrix.rds\", package = \"proteoDeconv\") mixed_samples <- readRDS(data_file)  signature_file <- system.file(\"extdata\", \"cd8t_mono_signature_matrix.rds\", package = \"proteoDeconv\") signature_matrix <- readRDS(signature_file)  # Run deconvolution result <- deconvolute_bayesdebulk(mixed_samples, signature_matrix) } # }"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersort.html","id":null,"dir":"Reference","previous_headings":"","what":"Deconvolute mixture data using CIBERSORT — deconvolute_cibersort","title":"Deconvolute mixture data using CIBERSORT — deconvolute_cibersort","text":"Applies CIBERSORT algorithm deconvolute bulk proteome data constituent cell types using signature matrix. function requires original CIBERSORT.R script sourced.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deconvolute mixture data using CIBERSORT — deconvolute_cibersort","text":"","code":"deconvolute_cibersort(   data,   signature,   QN = FALSE,   absolute = FALSE,   abs_method = \"sig.score\",   ... )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deconvolute mixture data using CIBERSORT — deconvolute_cibersort","text":"data numeric matrix containing mixture data genes row names samples columns. signature numeric matrix containing signature data genes row names cell types columns. QN Logical indicating whether quantile normalization performed (default FALSE). absolute Logical indicating whether absolute score computed (default FALSE). abs_method Method absolute scoring absolute TRUE (default \"sig.score\"). ... Additional arguments passed CIBERSORT function.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersort.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deconvolute mixture data using CIBERSORT — deconvolute_cibersort","text":"numeric matrix samples rows cell types columns, representing estimated proportion cell type sample. returned matrix excludes CIBERSORT's diagnostic columns (RMSE, P-value, Correlation).","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersort.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deconvolute mixture data using CIBERSORT — deconvolute_cibersort","text":"function requires original CIBERSORT.R script CIBERSORT website (https://cibersortx.stanford.edu/) sourced use. writes temporary files mixture data signature matrix, calls CIBERSORT function, processes results.","code":""},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersort.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deconvolute mixture data using CIBERSORT — deconvolute_cibersort","text":"","code":"if (FALSE) { # \\dontrun{ # First source the CIBERSORT.R script source(\"/path/to/CIBERSORT.R\")  # Load example data and signature matrix data_file <- system.file(\"extdata\", \"mixed_samples_matrix.rds\", package = \"proteoDeconv\") mixed_samples <- readRDS(data_file)  signature_file <- system.file(\"extdata\", \"cd8t_mono_signature_matrix.rds\", package = \"proteoDeconv\") signature_matrix <- readRDS(signature_file)  # Run deconvolution result <- deconvolute_cibersort(   data = mixed_samples,   signature = signature_matrix,   QN = FALSE,   absolute = FALSE ) } # }"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersortx.html","id":null,"dir":"Reference","previous_headings":"","what":"Deconvolute using CIBERSORTx Docker image — deconvolute_cibersortx","title":"Deconvolute using CIBERSORTx Docker image — deconvolute_cibersortx","text":"Performs deconvolution bulk proteome data constituent cell types using CIBERSORTx Docker image. function handles interaction Docker container processes results.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersortx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deconvolute using CIBERSORTx Docker image — deconvolute_cibersortx","text":"","code":"deconvolute_cibersortx(   data,   signature,   perm = 1,   rmbatch_S_mode = FALSE,   source_GEPs = NULL,   use_cibersortx = TRUE,   rmbatch_B_mode = FALSE,   QN = FALSE,   absolute = FALSE,   abs_method = \"sig.score\",   use_sudo = FALSE )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersortx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deconvolute using CIBERSORTx Docker image — deconvolute_cibersortx","text":"data numeric matrix containing mixture data genes row names samples columns. signature numeric matrix containing signature matrix genes row names cell types columns. perm integer specifying number permutations performed. Default 1. rmbatch_S_mode logical value indicating whether remove batch effects source GEPs mode. Default FALSE. source_GEPs matrix containing source gene expression profiles. Required rmbatch_S_mode TRUE. use_cibersortx logical value indicating whether use CIBERSORTx. Default TRUE. rmbatch_B_mode logical value indicating whether remove batch effects bulk mode. Default FALSE. QN logical value indicating whether perform quantile normalization. Default FALSE. absolute logical value indicating whether use absolute mode. Default FALSE. abs_method character string specifying method use absolute mode. Default \"sig.score\". use_sudo logical value indicating whether use sudo Docker commands. Default FALSE.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersortx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deconvolute using CIBERSORTx Docker image — deconvolute_cibersortx","text":"numeric matrix samples rows cell types columns, representing estimated proportion cell type sample.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersortx.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deconvolute using CIBERSORTx Docker image — deconvolute_cibersortx","text":"function requires CIBERSORTx Docker image installed CIBERSORTX_EMAIL CIBERSORTX_TOKEN environment variables set. can get credentials registering CIBERSORTx website (https://cibersortx.stanford.edu/). function creates temporary files mixture data signature matrix, runs CIBERSORTx Docker container, processes results. Note absolute mode currently supported Docker version.","code":""},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_cibersortx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deconvolute using CIBERSORTx Docker image — deconvolute_cibersortx","text":"","code":"if (FALSE) { # \\dontrun{ # Set required environment variables (ideally in .Renviron) Sys.setenv(CIBERSORTX_EMAIL = \"your.email@example.com\") Sys.setenv(CIBERSORTX_TOKEN = \"your-token-here\")  # Load example data and signature matrix data_file <- system.file(\"extdata\", \"mixed_samples_matrix.rds\", package = \"proteoDeconv\") mixed_samples <- readRDS(data_file)  signature_file <- system.file(\"extdata\", \"cd8t_mono_signature_matrix.rds\", package = \"proteoDeconv\") signature_matrix <- readRDS(signature_file)  # Run deconvolution with CIBERSORTx Docker result <- deconvolute_cibersortx(   data = mixed_samples,   signature = signature_matrix,   perm = 100,   QN = TRUE ) } # }"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_epic.html","id":null,"dir":"Reference","previous_headings":"","what":"Deconvolute bulk data using EPIC — deconvolute_epic","title":"Deconvolute bulk data using EPIC — deconvolute_epic","text":"Runs EPIC algorithm preprocessed proteomic data estimate cell type proportions mixed samples using reference signature matrix.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_epic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deconvolute bulk data using EPIC — deconvolute_epic","text":"","code":"deconvolute_epic(data, signature, with_other_cells = TRUE)"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_epic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deconvolute bulk data using EPIC — deconvolute_epic","text":"data numeric matrix bulk proteome data gene identifiers row names samples columns. signature numeric matrix reference signature profiles gene identifiers row names cell types columns. with_other_cells Logical; TRUE, EPIC include \"cells\" component output account cell types present reference. Default TRUE.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_epic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deconvolute bulk data using EPIC — deconvolute_epic","text":"numeric matrix samples rows cell types columns, representing estimated proportion cell type sample.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_epic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deconvolute bulk data using EPIC — deconvolute_epic","text":"function normalizes input data matrix signature matrix using handle_scaling function running EPIC deconvolution. EPIC algorithm uses constrained least squares regression estimate cell type proportions.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_epic.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Deconvolute bulk data using EPIC — deconvolute_epic","text":"Racle, J. et al. (2017). Simultaneous enumeration cancer immune cell types bulk tumor gene expression data. eLife, 6:e26476.","code":""},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/deconvolute_epic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deconvolute bulk data using EPIC — deconvolute_epic","text":"","code":"if (FALSE) { # \\dontrun{ # Load example data and signature matrix data_file <- system.file(\"extdata\", \"mixed_samples_matrix.rds\", package = \"proteoDeconv\") mixed_samples <- readRDS(data_file)  signature_file <- system.file(\"extdata\", \"cd8t_mono_signature_matrix.rds\", package = \"proteoDeconv\") signature_matrix <- readRDS(signature_file)  # Run EPIC deconvolution result <- deconvolute_epic(   data = mixed_samples,   signature = signature_matrix,   with_other_cells = TRUE )  # View first few rows of the result head(result) } # }"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/extract_identifiers.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract primary identifiers from e.g. protein groups — extract_identifiers","title":"Extract primary identifiers from e.g. protein groups — extract_identifiers","text":"Extracts primary identifier compound row identifiers matrix splitting separator keeping first entry.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/extract_identifiers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract primary identifiers from e.g. protein groups — extract_identifiers","text":"","code":"extract_identifiers(data, separator = \";\")"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/extract_identifiers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract primary identifiers from e.g. protein groups — extract_identifiers","text":"data numeric matrix compound identifiers (e.g. protein/gene groups) row names. separator character string used separate multiple identifiers. Default \";\".","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/extract_identifiers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract primary identifiers from e.g. protein groups — extract_identifiers","text":"matrix simplified identifiers row names, identifier first element original compound identifier.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/extract_identifiers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract primary identifiers from e.g. protein groups — extract_identifiers","text":"","code":"# Create matrix with compound identifiers (like protein groups) mat <- matrix(1:9, nrow = 3, ncol = 3) rownames(mat) <- c(\"P04637;P02340\", \"Q15796;O35182\", \"P01308;P01315;P01317\") colnames(mat) <- c(\"Sample1\", \"Sample2\", \"Sample3\")  # View original matrix print(mat) #>                      Sample1 Sample2 Sample3 #> P04637;P02340              1       4       7 #> Q15796;O35182              2       5       8 #> P01308;P01315;P01317       3       6       9  # Extract primary identifiers result <- extract_identifiers(mat) print(result) #>        Sample1 Sample2 Sample3 #> P04637       1       4       7 #> Q15796       2       5       8 #> P01308       3       6       9"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers.html","id":null,"dir":"Reference","previous_headings":"","what":"Get signature markers for deconvolution — get_signature_markers","title":"Get signature markers for deconvolution — get_signature_markers","text":"Extracts unique signature markers signature matrix use cell type deconvolution. function selects method identify cell type-specific markers.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get signature markers for deconvolution — get_signature_markers","text":"","code":"get_signature_markers(Y, signature_mat, method = \"limma\", ...)"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get signature markers for deconvolution — get_signature_markers","text":"Y numeric matrix bulk data gene identifiers row names. signature_mat numeric matrix signature marker values gene identifiers row names cell types columns. method method use marker selection: \"limma\" (default), \"simple\", pre-computed marker matrix. ... Additional arguments passed selected marker selection function.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get signature markers for deconvolution — get_signature_markers","text":"character matrix markers columns cell type, comparison cell type, gene name.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers_limma.html","id":null,"dir":"Reference","previous_headings":"","what":"Get signature markers using limma-based fold change method — get_signature_markers_limma","title":"Get signature markers using limma-based fold change method — get_signature_markers_limma","text":"Extracts unique signature markers signature matrix using fold-change approach. method calculates fold changes cell types selects genes significant differential expression.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers_limma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get signature markers using limma-based fold change method — get_signature_markers_limma","text":"","code":"get_signature_markers_limma(   Y,   signature_mat,   min_fold_change = 3,   min_expression = 0,   pseudo_count = 1e-10 )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers_limma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get signature markers using limma-based fold change method — get_signature_markers_limma","text":"Y numeric matrix bulk data gene identifiers row names. signature_mat numeric matrix signature marker values gene identifiers row names cell types columns. min_fold_change Minimum fold change required gene considered marker (default: 3). min_expression Minimum expression level required target cell type (default: 0). pseudo_count Small value added expression values avoid division zero (default: 1e-10).","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers_limma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get signature markers using limma-based fold change method — get_signature_markers_limma","text":"character matrix markers columns cell type, comparison cell type, gene name.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers_simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Get signature markers using simple threshold method — get_signature_markers_simple","title":"Get signature markers using simple threshold method — get_signature_markers_simple","text":"Extracts unique signature markers signature matrix using simple threshold-based approach. gene considered marker expression one cell type exceeds expression cell types specified fold change meets minimum expression threshold.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers_simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get signature markers using simple threshold method — get_signature_markers_simple","text":"","code":"get_signature_markers_simple(   Y,   signature_mat,   min_expression = 1000,   min_fold_change = 3 )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers_simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get signature markers using simple threshold method — get_signature_markers_simple","text":"Y numeric matrix bulk data gene identifiers row names. signature_mat numeric matrix signature marker values gene identifiers row names cell types columns. min_expression Minimum expression level required target cell type (default: 1000). min_fold_change Minimum fold change required compared cell types (default: 3).","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/get_signature_markers_simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get signature markers using simple threshold method — get_signature_markers_simple","text":"character matrix markers columns cell type, comparison cell type, gene name.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_duplicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle duplicate identifiers in an expression matrix — handle_duplicates","title":"Handle duplicate identifiers in an expression matrix — handle_duplicates","text":"Resolves duplicate row identifiers expression matrix using specified method.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_duplicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle duplicate identifiers in an expression matrix — handle_duplicates","text":"","code":"handle_duplicates(data, duplicate_mode = \"slice\")"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_duplicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handle duplicate identifiers in an expression matrix — handle_duplicates","text":"data numeric matrix containing expression data identifiers row names samples columns. duplicate_mode string specifying approach handle duplicates: \"slice\": Keep row maximum median value identifier (default) \"merge\": Merge duplicate rows taking column-wise median values","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_duplicates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handle duplicate identifiers in an expression matrix — handle_duplicates","text":"numeric matrix unique identifiers row names. number rows equal number unique identifiers input matrix.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_duplicates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Handle duplicate identifiers in an expression matrix — handle_duplicates","text":"","code":"# Create example matrix with duplicate identifiers mat <- matrix(1:12, nrow = 4, ncol = 3) rownames(mat) <- c(\"ID1\", \"ID2\", \"ID1\", \"ID3\") colnames(mat) <- c(\"Sample1\", \"Sample2\", \"Sample3\")  # View original matrix print(mat) #>     Sample1 Sample2 Sample3 #> ID1       1       5       9 #> ID2       2       6      10 #> ID1       3       7      11 #> ID3       4       8      12  # Handle duplicates by keeping rows with maximum median (default) result1 <- handle_duplicates(mat) print(result1) #>     Sample1 Sample2 Sample3 #> ID1       3       7      11 #> ID2       2       6      10 #> ID3       4       8      12  # Handle duplicates by merging rows result2 <- handle_duplicates(mat, duplicate_mode = \"merge\") print(result2) #>     Sample1 Sample2 Sample3 #> ID1       2       6      10 #> ID2       2       6      10 #> ID3       4       8      12"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_missing_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle missing values — handle_missing_values","title":"Handle missing values — handle_missing_values","text":"Imputes missing values expression matrix using various methods, including simple replacement lowest non-zero value sophisticated imputation techniques via MsCoreUtils package.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_missing_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle missing values — handle_missing_values","text":"","code":"handle_missing_values(data, imputation_mode = \"lowest_value\", ...)"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_missing_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handle missing values — handle_missing_values","text":"data numeric matrix containing data processed, identifiers row names samples columns. imputation_mode string specifying imputation method use: \"lowest_value\" (default): Replaces NAs lowest non-zero value matrix \"knn\": k-nearest neighbor imputation \"zero\": Replace NAs zeros \"MLE\": Maximum likelihood estimation \"bpca\": Bayesian principal component analysis \"RF\": Random Forest imputation \"min\": Replace NAs minimum value column \"MinDet\": Deterministic minimum value imputation \"MinProb\": Probabilistic minimum value imputation \"QRILC\": Quantile regression imputation left-censored data \"mixed\": Mixed imputation based feature-wise missingness \"nbavg\": Impute average neighbors ... Additional arguments passed MsCoreUtils::impute_matrix. See documentation function method-specific parameters.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_missing_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handle missing values — handle_missing_values","text":"matrix dimensions input, missing values imputed according specified method.","code":""},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_missing_values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Handle missing values — handle_missing_values","text":"","code":"# Create example matrix with missing values mat <- matrix(c(1.2, 3.4, NA, 5.6, NA, 7.8, 9.0, 2.1, 4.3), nrow = 3, ncol = 3) rownames(mat) <- c(\"Protein1\", \"Protein2\", \"Protein3\") colnames(mat) <- c(\"Sample1\", \"Sample2\", \"Sample3\")  # View original matrix print(mat) #>          Sample1 Sample2 Sample3 #> Protein1     1.2     5.6     9.0 #> Protein2     3.4      NA     2.1 #> Protein3      NA     7.8     4.3  # Impute missing values with lowest non-zero value (default) result1 <- handle_missing_values(mat) print(result1) #>          Sample1 Sample2 Sample3 #> Protein1     1.2     5.6     9.0 #> Protein2     3.4     1.2     2.1 #> Protein3     1.2     7.8     4.3  # Impute missing values using k-nearest neighbors if (FALSE) { # \\dontrun{ # Requires the 'impute' package result2 <- handle_missing_values(mat, imputation_mode = \"knn\") print(result2) } # }"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle scaling of protein abundance data — handle_scaling","title":"Handle scaling of protein abundance data — handle_scaling","text":"Scales protein abundance data optionally converting log2 scale linear scale /applying TPM-like normalization proteomics data comparison.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle scaling of protein abundance data — handle_scaling","text":"","code":"handle_scaling(data, unlog = FALSE, tpm = FALSE)"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handle scaling of protein abundance data — handle_scaling","text":"data numeric matrix containing protein abundance data identifiers row names samples columns. unlog logical value indicating whether unlog data (convert log2 scale). Default FALSE. tpm logical value indicating whether apply TPM-like normalization (adapting Transcripts Per Million proteomics). Default FALSE.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handle scaling of protein abundance data — handle_scaling","text":"numeric matrix scaled protein abundance data according specified options.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_scaling.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Handle scaling of protein abundance data — handle_scaling","text":"function combines functionality unlog2_data convert_to_tpm provide flexible way handle common scaling operations proteomics data.","code":""},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/handle_scaling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Handle scaling of protein abundance data — handle_scaling","text":"","code":"# Create log2-transformed protein abundance matrix log2_mat <- matrix(rnorm(12, mean = 10, sd = 2), nrow = 4, ncol = 3) rownames(log2_mat) <- paste0(\"Protein\", 1:4) colnames(log2_mat) <- paste0(\"Sample\", 1:3)  # Convert from log2 to linear scale only linear_mat <- handle_scaling(log2_mat, unlog = TRUE, tpm = FALSE)  # Convert from log2 to linear scale and then apply TPM-like normalization tpm_mat <- handle_scaling(log2_mat, unlog = TRUE, tpm = TRUE)  # Apply TPM-like normalization to already linear protein abundance data linear_data <- matrix(abs(rnorm(12, mean = 500, sd = 200)), nrow = 4, ncol = 3) tpm_only <- handle_scaling(linear_data, unlog = FALSE, tpm = TRUE)"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/map_cell_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Map column names to cell type groups using patterns — map_cell_groups","title":"Map column names to cell type groups using patterns — map_cell_groups","text":"Maps character vector column names predefined cell type categories matching patterns, optional regex support.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/map_cell_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map column names to cell type groups using patterns — map_cell_groups","text":"","code":"map_cell_groups(   column_names,   mapping_rules,   default_group = \"Unknown\",   verbose = FALSE,   use_regex = TRUE )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/map_cell_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map column names to cell type groups using patterns — map_cell_groups","text":"column_names character vector column names mapped cell type groups. mapping_rules named list names target cell type groups values character vectors patterns identify columns belonging group. default_group string represents default group name columns matching pattern. Default \"Unknown\". verbose Logical. TRUE, prints mapping process messages showing columns mapped groups columns remained unmapped. Default FALSE. use_regex Logical. TRUE (default), treats patterns mapping_rules regular expressions. FALSE, performs exact string matching.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/map_cell_groups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map column names to cell type groups using patterns — map_cell_groups","text":"character vector length column_names, containing mapped cell type group column name. Columns match pattern assigned default_group.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/map_cell_groups.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map column names to cell type groups using patterns — map_cell_groups","text":"function iterates mapping_rules list attempts match column name patterns cell type group. first matching group order list assigned. use_regex = TRUE, patterns treated regular expressions matching case-insensitive. use_regex = FALSE, exact string matching performed, case-sensitive.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/map_cell_groups.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map column names to cell type groups using patterns — map_cell_groups","text":"","code":"# Example column names from a dataset cols <- c(\"CD8_T_cell\", \"T_cell\", \"B_cell\",           \"NK_cell\", \"Monocyte\", \"Unknown_cell\")  # Define simple mapping rules for cell types mapping <- list(   \"T_cell\" = c(\"CD8_T_cell\", \"T_cell\"),   \"B_cell\" = c(\"B_cell\"),   \"NK_cell\" = c(\"NK_cell\"),   \"Monocyte\" = c(\"Monocyte\") )  # Map column names to cell types using exact matching cell_types <- map_cell_groups(cols, mapping, use_regex = FALSE) print(data.frame(column = cols, cell_type = cell_types)) #>         column cell_type #> 1   CD8_T_cell    T_cell #> 2       T_cell    T_cell #> 3       B_cell    B_cell #> 4      NK_cell   NK_cell #> 5     Monocyte  Monocyte #> 6 Unknown_cell   Unknown  # Define mapping rules using regex patterns mapping_regex <- list(   \"T_cell\" = c(\"CD8.*\", \"T_cell\"),   \"B_cell\" = c(\"B[-_]?cell\"),   \"NK_cell\" = c(\"NK[-_]?cell\"),   \"Monocyte\" = c(\"Mono.*\") )  # Map using regex patterns (default) cell_types_regex <- map_cell_groups(cols, mapping_regex) print(data.frame(column = cols, cell_type = cell_types_regex)) #>         column cell_type #> 1   CD8_T_cell    T_cell #> 2       T_cell    T_cell #> 3       B_cell    B_cell #> 4      NK_cell   NK_cell #> 5     Monocyte  Monocyte #> 6 Unknown_cell   Unknown"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/proteoDeconv-package.html","id":null,"dir":"Reference","previous_headings":"","what":"proteoDeconv: Enabling Cell-Type Deconvolution of Proteomics Data — proteoDeconv-package","title":"proteoDeconv: Enabling Cell-Type Deconvolution of Proteomics Data — proteoDeconv-package","text":"Tools deconvoluting proteomics data identify quantify cell types (e.g., immune cell types) complex biological samples.","code":""},{"path":[]},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/proteoDeconv-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"proteoDeconv: Enabling Cell-Type Deconvolution of Proteomics Data — proteoDeconv-package","text":"Maintainer: Måns Zamore mans.zamore@immun.lth.se (ORCID)","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/simulate_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate artifical mixtures from bulk proteome measurements — simulate_data","title":"Simulate artifical mixtures from bulk proteome measurements — simulate_data","text":"function simulates bulk proteome data mixing bulk sample measurements.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/simulate_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate artifical mixtures from bulk proteome measurements — simulate_data","text":"","code":"simulate_data(   data,   cell_types,   seed = NULL,   ncells = 100,   nsamples = 100,   filter_genes = TRUE,   scenario = \"random\",   whitelist = NULL,   blacklist = NULL )"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/simulate_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate artifical mixtures from bulk proteome measurements — simulate_data","text":"data numeric matrix containing protein abundance data protein identifiers row names samples columns. cell_types character vector indicating cell type associated column input matrix. Must length number columns data. seed integer used random seed reproducibility. Default NULL (seed). ncells Integer specifying number cells use simulated bulk sample. nsamples Integer specifying number bulk samples simulate. Default 100. filter_genes Logical; whether filter proteins/genes low expression simulation. Default TRUE. scenario String specifying simulation scenario: \"random\" (default): Random cell type proportions sample \"even\": Even proportions cell types See SimBu documentation additional scenarios whitelist Optional character vector cell types include simulation. provided, cell types used. Default NULL (use ). blacklist Optional character vector cell types exclude simulation. Default NULL (exclude none).","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/simulate_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate artifical mixtures from bulk proteome measurements — simulate_data","text":"list containing two matrices: simulated_data: Matrix simulated bulk protein abundance data (proteins rows, simulated samples columns) cell_fractions: Matrix cell type fractions used simulation (cell types rows, simulated samples columns)","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/simulate_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate artifical mixtures from bulk proteome measurements — simulate_data","text":"function uses SimBu package generate synthetic bulk samples artifically mixing samples.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/simulate_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate artifical mixtures from bulk proteome measurements — simulate_data","text":"","code":"# Create example data cell_data <- matrix(abs(rnorm(1500, mean = 500, sd = 200)), nrow = 100, ncol = 15) rownames(cell_data) <- paste0(\"Protein\", 1:100) colnames(cell_data) <- paste0(\"Cell\", 1:15)  # Define cell types cell_types <- rep(c(\"T_cell\", \"B_cell\", \"Monocyte\"), each = 5)  # Run simulation if (FALSE) { # \\dontrun{ sim_results <- simulate_data(   data = cell_data,   cell_types = cell_types,   seed = 42,   nsamples = 20,   scenario = \"random\" )  dim(sim_results$simulated_data) dim(sim_results$cell_fractions) } # }"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/unlog2_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert data from log2 scale to linear scale — unlog2_data","title":"Convert data from log2 scale to linear scale — unlog2_data","text":"Transforms log2-transformed expression data back linear scale calculating 2^x value input matrix.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/unlog2_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert data from log2 scale to linear scale — unlog2_data","text":"","code":"unlog2_data(data)"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/unlog2_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert data from log2 scale to linear scale — unlog2_data","text":"data numeric matrix containing log2-transformed data identifiers row names samples columns.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/unlog2_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert data from log2 scale to linear scale — unlog2_data","text":"numeric matrix dimensions input, values converted linear scale (2^x).","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/unlog2_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert data from log2 scale to linear scale — unlog2_data","text":"function can used convert log2-transformed proteomics gene expression data back original scale downstream analyses require linear values. preserves row column names input matrix.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/unlog2_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert data from log2 scale to linear scale — unlog2_data","text":"","code":"# Create log2-transformed data matrix log2_mat <- matrix(rnorm(12, mean = 10, sd = 2), nrow = 4, ncol = 3) rownames(log2_mat) <- paste0(\"Protein\", 1:4) colnames(log2_mat) <- paste0(\"Sample\", 1:3)  # View original log2 values print(log2_mat) #>            Sample1  Sample2  Sample3 #> Protein1  6.780849 12.25661 11.75693 #> Protein2  7.900580 10.87000 10.70160 #> Protein3 14.104068 11.09767 10.09976 #> Protein4 10.352873 11.29484 11.67150  # Convert to linear scale linear_mat <- unlog2_data(log2_mat) print(linear_mat) #>             Sample1  Sample2  Sample3 #> Protein1   109.9611 4893.377 3460.889 #> Protein2   238.9525 1871.531 1665.334 #> Protein3 17609.5198 2191.445 1097.313 #> Protein4  1307.7516 2512.376 3261.905"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/update_gene_symbols.html","id":null,"dir":"Reference","previous_headings":"","what":"Update gene symbols in a matrix to approved HGNC nomenclature — update_gene_symbols","title":"Update gene symbols in a matrix to approved HGNC nomenclature — update_gene_symbols","text":"function checks updates gene symbols matrix's row names ensure conform current approved HGNC (HUGO Gene Nomenclature Committee) standards. Non-standard outdated gene symbols replaced current official symbols.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/update_gene_symbols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update gene symbols in a matrix to approved HGNC nomenclature — update_gene_symbols","text":"","code":"update_gene_symbols(data, verbose = FALSE)"},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/update_gene_symbols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update gene symbols in a matrix to approved HGNC nomenclature — update_gene_symbols","text":"data numeric matrix containing gene expression protein abundance data gene identifiers row names. verbose logical value indicating whether print detailed messages number approved, non-approved, unmappable gene symbols. Default FALSE.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/update_gene_symbols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update gene symbols in a matrix to approved HGNC nomenclature — update_gene_symbols","text":"matrix updated gene symbols row names. Rows unmappable symbols (suggested symbol found) removed output.","code":""},{"path":"https://computationalproteomics.github.io/proteoDeconv/reference/update_gene_symbols.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Update gene symbols in a matrix to approved HGNC nomenclature — update_gene_symbols","text":"function uses HGNChelper package check standardize gene symbols based predefined gene symbols map. important ensuring consistency gene naming across datasets avoiding issues outdated non-standard gene symbols.","code":""}]
